<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ABIS Live - Enhanced v4.0</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: 0; }
    }
    .animate-in { animation: fadeIn 0.7s ease-out; }
    .scrollbar-hide::-webkit-scrollbar { display: none; }
    .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
    .bet-selected {
      animation: pulse 0.5s ease-in-out;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }
  </style>
</head>
<body class="bg-slate-950 text-slate-200">
  <div id="root"></div>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useMemo } = React;

    // Lucide Icons (keeping all existing icons plus new ones)
    const Shield = ({className, size=24}) => (
      <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
      </svg>
    );

    const TrendingUp = ({className, size=24}) => (
      <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <polyline points="23 6 13.5 15.5 8.5 10.5 1 18"/><polyline points="17 6 23 6 23 12"/>
      </svg>
    );

    const Zap = ({className, size=24}) => (
      <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" strokeWidth="2">
        <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/>
      </svg>
    );

    const LayoutDashboard = ({size=24}) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <rect x="3" y="3" width="7" height="9"/><rect x="14" y="3" width="7" height="5"/><rect x="14" y="12" width="7" height="9"/><rect x="3" y="16" width="7" height="5"/>
      </svg>
    );

    const History = ({className, size=24}) => (
      <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <path d="M3 3v5h5"/><path d="M3.05 13A9 9 0 1 0 6 5.3L3 8"/>
      </svg>
    );

    const Wallet = ({className, size=24}) => (
      <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <path d="M21 12V7H5a2 2 0 0 1 0-4h14v4"/><path d="M3 5v14a2 2 0 0 0 2 2h16v-5"/><path d="M18 12a2 2 0 0 0 0 4h4v-4Z"/>
      </svg>
    );

    const Users = ({size=24}) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/>
      </svg>
    );

    const ArrowUpRight = ({size=24}) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <line x1="7" y1="17" x2="17" y2="7"/><polyline points="7 7 17 7 17 17"/>
      </svg>
    );

    const CheckSquare = ({size=24}) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <polyline points="9 11 12 14 22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/>
      </svg>
    );

    const Calculator = ({size=24}) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <rect x="4" y="2" width="16" height="20" rx="2"/><line x1="8" y1="6" x2="16" y2="6"/><line x1="16" y1="14" x2="16" y2="14.01"/><line x1="12" y1="14" x2="12" y2="14.01"/><line x1="8" y1="14" x2="8" y2="14.01"/><line x1="16" y1="18" x2="16" y2="18.01"/><line x1="12" y1="18" x2="12" y2="18.01"/><line x1="8" y1="18" x2="8" y2="18.01"/>
      </svg>
    );

    const Menu = () => (
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/>
      </svg>
    );

    const X = () => (
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
      </svg>
    );

    const Target = ({size=24}) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/>
      </svg>
    );

    const Trash = ({size=24}) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/>
      </svg>
    );

    const Edit = ({size=24}) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
      </svg>
    );

    const Layers = ({size=24}) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/>
      </svg>
    );

    const Plus = ({size=24}) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
      </svg>
    );

    const Check = ({size=24}) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <polyline points="20 6 9 17 4 12"/>
      </svg>
    );

    // ============================================================================
    // SMART CACHE MANAGER
    // ============================================================================
    class SmartCache {
      constructor() {
        this.prefix = 'abis_cache_';
      }

      set(key, data, ttlMinutes = 60) {
        const item = {
          data: data,
          expires: Date.now() + (ttlMinutes * 60 * 1000)
        };
        try {
          localStorage.setItem(this.prefix + key, JSON.stringify(item));
        } catch (e) {
          console.warn('Cache storage failed:', e);
        }
      }

      get(key) {
        try {
          const item = localStorage.getItem(this.prefix + key);
          if (!item) return null;
          
          const parsed = JSON.parse(item);
          if (Date.now() > parsed.expires) {
            localStorage.removeItem(this.prefix + key);
            return null;
          }
          
          return parsed.data;
        } catch (e) {
          return null;
        }
      }

      clear(pattern) {
        Object.keys(localStorage).forEach(key => {
          if (key.startsWith(this.prefix + pattern)) {
            localStorage.removeItem(key);
          }
        });
      }
    }

    const cache = new SmartCache();

    const App = () => {
      const [activeTab, setActiveTab] = useState('dashboard');
      const [initialCapital, setInitialCapital] = useState("");
      const [currentBankroll, setCurrentBankroll] = useState(() => {
        const saved = localStorage.getItem('abis_bankroll');
        return saved ? parseFloat(saved) : 0;
      });
      const [userStakeInput, setUserStakeInput] = useState(() => {
        const saved = localStorage.getItem('abis_default_stake');
        return saved ? parseFloat(saved) : 10;
      });
      const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
      const [placedBets, setPlacedBets] = useState(() => {
        const saved = localStorage.getItem('abis_placed_bets');
        return saved ? JSON.parse(saved) : [];
      });
      const [settledBets, setSettledBets] = useState(() => {
        const saved = localStorage.getItem('abis_settled_bets');
        return saved ? JSON.parse(saved) : [];
      });
      const [manualPLAdjustment, setManualPLAdjustment] = useState(() => {
        const saved = localStorage.getItem('abis_manual_pl');
        return saved ? parseFloat(saved) : 0;
      });

      const [opportunities, setOpportunities] = useState([]);
      const [isLoadingOpportunities, setIsLoadingOpportunities] = useState(false);
      const [lastDataFetch, setLastDataFetch] = useState(null);
      const [oppsError, setOppsError] = useState(null);
      const [laLigaMatches, setLaLigaMatches] = useState([]);
      const [isLoadingLaLiga, setIsLoadingLaLiga] = useState(false);
      const [apiUsage, setApiUsage] = useState({ oddsAPI: 0, footballData: 0 });

      // NEW: Multi-bet selection state
      const [selectedBets, setSelectedBets] = useState([]);
      const [showBetSlip, setShowBetSlip] = useState(false);
      const [accumulatorStake, setAccumulatorStake] = useState('');

      // API Configuration
      const API_KEYS = {
        primary: "0d7491630a8624fe87ea1da0dad2ea3f",
        backup: "64a74abb6980d161caf1ab8ff856dea9",
        footballData: "ad3bee407db9f5221c7965ef2055f174"
      };

      // League Configuration
      const LEAGUES = {
        uk: [
          { key: 'soccer_epl', name: 'Premier League', fdId: 2021 },
          { key: 'soccer_efl_champ', name: 'Championship', fdId: 2016 },
          { key: 'soccer_england_league1', name: 'League One', fdId: 2030 },
          { key: 'soccer_england_league2', name: 'League Two', fdId: 2054 },
          { key: 'soccer_fa_cup', name: 'FA Cup', fdId: 2055 },
          { key: 'soccer_england_efl_cup', name: 'EFL Cup', fdId: 2139 },
          { key: 'soccer_spl', name: 'Scottish Premiership', fdId: 2084 },
          { key: 'soccer_england_national_league', name: 'National League', fdId: 2053 }
        ],
        europe: [
          { key: 'soccer_spain_la_liga', name: 'La Liga', fdId: 2014 },
          { key: 'soccer_germany_bundesliga', name: 'Bundesliga', fdId: 2002 },
          { key: 'soccer_italy_serie_a', name: 'Serie A', fdId: 2019 },
          { key: 'soccer_france_ligue_one', name: 'Ligue 1', fdId: 2015 },
          { key: 'soccer_netherlands_eredivisie', name: 'Eredivisie', fdId: 2003 },
          { key: 'soccer_portugal_primeira_liga', name: 'Primeira Liga', fdId: 2017 },
          { key: 'soccer_belgium_first_div', name: 'Jupiler Pro League', fdId: 2009 },
          { key: 'soccer_turkey_super_league', name: 'S√ºper Lig', fdId: 2070 }
        ]
      };

      // Save to localStorage
      useEffect(() => {
        if (currentBankroll >= 0) {
          localStorage.setItem('abis_bankroll', currentBankroll.toString());
        }
      }, [currentBankroll]);

      useEffect(() => {
        localStorage.setItem('abis_default_stake', userStakeInput.toString());
      }, [userStakeInput]);

      useEffect(() => {
        localStorage.setItem('abis_placed_bets', JSON.stringify(placedBets));
      }, [placedBets]);

      useEffect(() => {
        localStorage.setItem('abis_settled_bets', JSON.stringify(settledBets));
      }, [settledBets]);

      useEffect(() => {
        localStorage.setItem('abis_manual_pl', manualPLAdjustment.toString());
      }, [manualPLAdjustment]);

      // ============================================================================
      // API FETCHERS
      // ============================================================================

      const fetchDirectOdds = async (sport, apiKey, useCache = true) => {
        if (useCache) {
          const cached = cache.get(`odds_${sport}`);
          if (cached) {
            console.log(`‚úì Using cached odds for ${sport}`);
            return cached;
          }
        }

        const url = `https://api.the-odds-api.com/v4/sports/${sport}/odds/?apiKey=${apiKey}&regions=uk&markets=h2h&oddsFormat=decimal`;
        
        try {
          const response = await fetch(url);
          setApiUsage(prev => ({ ...prev, oddsAPI: prev.oddsAPI + 1 }));
          
          if (response.ok) {
            const data = await response.json();
            cache.set(`odds_${sport}`, data, 10);
            return data;
          } else if (response.status === 429) {
            console.log('Rate limit hit');
            return null;
          } else {
            console.error(`API error for ${sport}: ${response.status}`);
            return [];
          }
        } catch (err) {
          console.error(`Fetch error for ${sport}:`, err);
          return [];
        }
      };

      const fetchStandings = async (leagueId) => {
        if (!leagueId) return null;

        const cached = cache.get(`standings_${leagueId}`);
        if (cached) {
          console.log(`‚úì Using cached standings for league ${leagueId}`);
          return cached;
        }

        const url = `https://api.football-data.org/v4/competitions/${leagueId}/standings`;
        
        try {
          const response = await fetch(url, {
            headers: { 'X-Auth-Token': API_KEYS.footballData }
          });
          
          setApiUsage(prev => ({ ...prev, footballData: prev.footballData + 1 }));

          if (response.ok) {
            const data = await response.json();
            const table = data.standings?.[0]?.table;
            if (table) {
              cache.set(`standings_${leagueId}`, table, 360);
              return table;
            }
          }
          return null;
        } catch (err) {
          console.error(`Standings fetch error:`, err);
          return null;
        }
      };

      // ============================================================================
      // ENHANCED CONFIDENCE CALCULATION WITH DETAILED FACTORS
      // ============================================================================

      const calculateEnhancedConfidence = (event, homeOdds, awayOdds, drawOdds, standings, allBookmakers) => {
        let confidence = 0;
        let factors = [];
        let insights = [];

        const homeProb = (1 / homeOdds) * 100;
        const awayProb = (1 / awayOdds) * 100;
        const drawProb = (1 / drawOdds) * 100;

        let bestProb = Math.max(homeProb, awayProb, drawProb);
        
        // Base market confidence (50-80 points)
        let oddsConfidence = 50 + (bestProb - 50) * 0.6;
        oddsConfidence = Math.min(80, Math.max(50, oddsConfidence));
        
        confidence = oddsConfidence;
        factors.push({ 
          name: 'Market Probability', 
          value: oddsConfidence.toFixed(1), 
          max: 80,
          description: `Implied probability: ${bestProb.toFixed(1)}%`
        });

        // Bookmaker consensus analysis (0-8 points)
        if (allBookmakers && allBookmakers.length >= 2) {
          const oddsVariance = calculateOddsVariance(allBookmakers, event.home_team, event.away_team);
          let consensusBonus = 0;
          let consensusDesc = '';
          
          if (oddsVariance < 0.05) {
            consensusBonus = 8;
            consensusDesc = `${allBookmakers.length} bookmakers strongly agree (variance: ${(oddsVariance * 100).toFixed(1)}%)`;
            insights.push(`Strong market consensus across ${allBookmakers.length} bookmakers suggests high certainty`);
          } else if (oddsVariance < 0.1) {
            consensusBonus = 5;
            consensusDesc = `${allBookmakers.length} bookmakers moderately agree (variance: ${(oddsVariance * 100).toFixed(1)}%)`;
            insights.push(`Moderate agreement across ${allBookmakers.length} bookmakers`);
          } else if (oddsVariance < 0.2) {
            consensusBonus = 2;
            consensusDesc = `${allBookmakers.length} bookmakers show some variance (${(oddsVariance * 100).toFixed(1)}%)`;
            insights.push(`Some disagreement among ${allBookmakers.length} bookmakers - market uncertainty`);
          } else {
            consensusBonus = 0;
            consensusDesc = `High variance among ${allBookmakers.length} bookmakers (${(oddsVariance * 100).toFixed(1)}%) - uncertain market`;
            insights.push(`Significant disagreement among bookmakers indicates uncertainty`);
          }
          
          confidence += consensusBonus;
          factors.push({ 
            name: 'Bookmaker Consensus', 
            value: consensusBonus.toFixed(1), 
            max: 8,
            description: consensusDesc
          });
        }

        // League position and form analysis (0-6 points)
        if (standings) {
          const homeTeam = findTeamInStandings(standings, event.home_team);
          const awayTeam = findTeamInStandings(standings, event.away_team);

          if (homeTeam && awayTeam) {
            let positionBonus = 0;
            const positionDiff = Math.abs(homeTeam.position - awayTeam.position);

            if (positionDiff >= 10) {
              positionBonus = 4;
              insights.push(`Large position gap: ${homeTeam.position}th vs ${awayTeam.position}th (${positionDiff} places)`);
            } else if (positionDiff >= 5) {
              positionBonus = 2;
              insights.push(`Moderate position gap: ${homeTeam.position}th vs ${awayTeam.position}th`);
            } else if (positionDiff >= 3) {
              positionBonus = 1;
            }

            // Detailed form analysis
            const homeForm = homeTeam.form ? calculateFormScore(homeTeam.form) : 0;
            const awayForm = awayTeam.form ? calculateFormScore(awayTeam.form) : 0;
            const formDiff = Math.abs(homeForm - awayForm);
            const formBonus = Math.min(2, formDiff * 0.4);

            if (homeTeam.form || awayTeam.form) {
              const homeFormDesc = homeTeam.form ? `${homeTeam.form} (score: ${homeForm.toFixed(1)})` : 'N/A';
              const awayFormDesc = awayTeam.form ? `${awayTeam.form} (score: ${awayForm.toFixed(1)})` : 'N/A';
              
              if (formDiff > 2) {
                insights.push(`Significant form difference - Home: ${homeFormDesc}, Away: ${awayFormDesc}`);
              }
            }

            const totalPositionBonus = Math.min(6, positionBonus + formBonus);
            confidence += totalPositionBonus;
            
            factors.push({ 
              name: 'League Position & Form', 
              value: totalPositionBonus.toFixed(1), 
              max: 6,
              description: `Positions: ${homeTeam.position}th vs ${awayTeam.position}th | Form: ${homeTeam.form || 'N/A'} vs ${awayTeam.form || 'N/A'}`
            });
          }
        }

        // Home advantage analysis (0-3 points)
        let homeAdvantage = 0;
        if (homeProb > awayProb && homeProb > drawProb) {
          homeAdvantage = 3;
          insights.push('Home team favoured - home advantage factor active');
        } else if (homeProb > awayProb) {
          homeAdvantage = 1;
        }
        confidence += homeAdvantage;
        if (homeAdvantage > 0) {
          factors.push({ 
            name: 'Home Advantage', 
            value: homeAdvantage.toFixed(1), 
            max: 3,
            description: homeAdvantage === 3 ? 'Strong home advantage' : 'Moderate home factor'
          });
        }

        // Timing analysis (0-2 points)
        const kickoffTime = new Date(event.commence_time);
        const hoursUntilKickoff = (kickoffTime - new Date()) / (1000 * 60 * 60);
        
        let timingBonus = 0;
        let timingDesc = '';
        if (hoursUntilKickoff < 6) {
          timingBonus = 2;
          timingDesc = `Imminent kickoff (<6 hours) - odds more reliable`;
        } else if (hoursUntilKickoff < 24) {
          timingBonus = 1;
          timingDesc = `Kickoff within 24 hours - recent odds`;
        } else {
          timingDesc = `${Math.round(hoursUntilKickoff)} hours until kickoff`;
        }
        confidence += timingBonus;
        if (timingBonus > 0) {
          factors.push({ 
            name: 'Timing Factor', 
            value: timingBonus.toFixed(1), 
            max: 2,
            description: timingDesc
          });
        }

        // Favorite strength analysis (0-6 points)
        const favoriteStrength = Math.max(homeProb, awayProb, drawProb);
        let strengthBonus = 0;
        let strengthDesc = '';
        
        if (favoriteStrength > 75) {
          strengthBonus = 6;
          strengthDesc = 'Overwhelming favourite (>75% probability)';
          insights.push('Market shows overwhelming confidence in outcome');
        } else if (favoriteStrength > 65) {
          strengthBonus = 4;
          strengthDesc = 'Clear favourite (65-75% probability)';
          insights.push('Strong favourite identified by market');
        } else if (favoriteStrength > 55) {
          strengthBonus = 2;
          strengthDesc = 'Moderate favourite (55-65% probability)';
        } else {
          strengthDesc = 'Balanced match - no clear favourite';
          insights.push('Evenly matched - higher risk');
        }
        
        confidence += strengthBonus;
        if (strengthBonus > 0) {
          factors.push({ 
            name: 'Favourite Strength', 
            value: strengthBonus.toFixed(1), 
            max: 6,
            description: strengthDesc
          });
        }

        confidence = Math.min(95, Math.max(50, Math.round(confidence)));

        return { confidence, factors, insights };
      };

      const calculateOddsVariance = (bookmakers, homeTeam, awayTeam) => {
        const homeOddsList = [];
        const awayOddsList = [];

        bookmakers.forEach(bookie => {
          const market = bookie.markets?.find(m => m.key === 'h2h');
          if (market) {
            const homeOdds = market.outcomes?.find(o => o.name === homeTeam)?.price;
            const awayOdds = market.outcomes?.find(o => o.name === awayTeam)?.price;
            if (homeOdds) homeOddsList.push(homeOdds);
            if (awayOdds) awayOddsList.push(awayOdds);
          }
        });

        if (homeOddsList.length < 2) return 1;

        const homeVariance = calculateVariance(homeOddsList);
        const awayVariance = calculateVariance(awayOddsList);
        
        return (homeVariance + awayVariance) / 2;
      };

      const calculateVariance = (numbers) => {
        const mean = numbers.reduce((a, b) => a + b, 0) / numbers.length;
        const variance = numbers.reduce((sum, num) => sum + Math.pow(num - mean, 2), 0) / numbers.length;
        return Math.sqrt(variance) / mean;
      };

      const findTeamInStandings = (standings, teamName) => {
        const nameLower = teamName.toLowerCase();
        return standings.find(t => {
          const sName = t.team.name.toLowerCase();
          return sName.includes(nameLower) || nameLower.includes(sName) || 
                 sName.split(' ')[0] === nameLower.split(' ')[0];
        });
      };

      const calculateFormScore = (formString) => {
        if (!formString) return 0;
        const matches = formString.split(',');
        let score = 0;
        matches.forEach((result, idx) => {
          const weight = matches.length - idx;
          if (result === 'W') score += 3 * weight;
          else if (result === 'D') score += 1 * weight;
        });
        return score / 15;
      };

      const analyzeMatch = (event, leagueName, standings) => {
        const allBookmakers = event.bookmakers || [];
        const bookmaker = allBookmakers[0];
        const market = bookmaker?.markets?.find(m => m.key === 'h2h');
        
        if (!market || !market.outcomes || market.outcomes.length < 2) {
          return null;
        }

        const homeOutcome = market.outcomes.find(o => o.name === event.home_team);
        const awayOutcome = market.outcomes.find(o => o.name === event.away_team);
        const drawOutcome = market.outcomes.find(o => o.name === 'Draw');

        if (!homeOutcome || !awayOutcome) return null;

        const homeOdds = homeOutcome.price;
        const awayOdds = awayOutcome.price;
        const drawOdds = drawOutcome?.price || 3.5;

        const homeProb = (1 / homeOdds) * 100;
        const awayProb = (1 / awayOdds) * 100;
        const drawProb = (1 / drawOdds) * 100;

        let selection, odds, predictedScore, strategy;

        // Determine selection with more detailed reasoning
        if (homeProb > awayProb && homeProb > drawProb) {
          selection = "Home Win";
          odds = homeOdds;
          predictedScore = homeProb > 70 ? "3-0" : homeProb > 60 ? "2-0" : "2-1";
          
          if (homeOdds < 1.3) {
            strategy = "Overwhelming Home Favourite - High Stakes Match";
          } else if (homeOdds < 1.5) {
            strategy = "Heavy Home Favourite - Strong Home Position";
          } else if (homeOdds < 2.0) {
            strategy = "Clear Home Favourite - Home Advantage";
          } else {
            strategy = "Home Win Likely - Competitive Match";
          }
        } else if (awayProb > homeProb && awayProb > drawProb) {
          selection = "Away Win";
          odds = awayOdds;
          predictedScore = awayProb > 70 ? "0-3" : awayProb > 60 ? "0-2" : "1-2";
          
          if (awayOdds < 1.5) {
            strategy = "Strong Away Form - Dominant Visitor";
          } else if (awayOdds < 2.0) {
            strategy = "Away Favourite - Strong Away Record";
          } else {
            strategy = "Away Win Possible - Competitive Away Side";
          }
        } else {
          selection = "Draw";
          odds = drawOdds;
          predictedScore = "1-1";
          strategy = "Evenly Matched Teams - Draw Likely";
        }

        const { confidence, factors, insights } = calculateEnhancedConfidence(
          event, homeOdds, awayOdds, drawOdds, standings, allBookmakers
        );

        // Generate detailed reasoning
        const reasoning = `${selection} recommended with ${confidence}% confidence based on analysis of ${factors.length} key factors across ${allBookmakers.length} bookmakers. ${insights.join('. ')}.`;

        return {
          id: event.id,
          event: `${event.home_team} vs ${event.away_team}`,
          league: leagueName,
          selection,
          odds,
          confidence,
          confidenceFactors: factors,
          reasoning,
          insights,
          predictedScore,
          scoreConfidence: Math.max(65, confidence - Math.floor(Math.random() * 8 + 3)),
          strategy,
          bookie: bookmaker?.title || 'Market Average',
          bookmakerCount: allBookmakers.length,
          commence_time: event.commence_time,
          homeOdds,
          awayOdds,
          drawOdds,
          type: 'Enhanced Analysis',
          customerType: 'All Users',
          url: `https://www.google.com/search?q=${encodeURIComponent(event.home_team + ' vs ' + event.away_team + ' odds')}`,
          homeTeam: event.home_team,
          awayTeam: event.away_team
        };
      };

      // ============================================================================
      // ACCUMULATOR SUGGESTIONS
      // ============================================================================

      const generateAccumulatorSuggestions = (opportunities) => {
        if (opportunities.length < 2) return [];

        const suggestions = [];
        
        // Filter high-confidence bets (80%+)
        const highConfidence = opportunities.filter(o => o.confidence >= 80);
        
        if (highConfidence.length >= 2) {
          // Suggestion 1: Top 3 highest confidence
          const top3 = [...highConfidence].sort((a, b) => b.confidence - a.confidence).slice(0, 3);
          if (top3.length >= 2) {
            const combinedOdds = top3.reduce((acc, bet) => acc * bet.odds, 1);
            suggestions.push({
              name: 'Safe Accumulator',
              bets: top3,
              totalOdds: combinedOdds,
              avgConfidence: top3.reduce((sum, b) => sum + b.confidence, 0) / top3.length,
              description: `${top3.length} highest confidence selections`,
              risk: 'Low'
            });
          }
        }

        // Suggestion 2: Same league accumulator
        const leagueGroups = {};
        opportunities.forEach(opp => {
          if (!leagueGroups[opp.league]) leagueGroups[opp.league] = [];
          leagueGroups[opp.league].push(opp);
        });

        Object.entries(leagueGroups).forEach(([league, bets]) => {
          if (bets.length >= 2) {
            const topBets = bets.filter(b => b.confidence >= 75).slice(0, 3);
            if (topBets.length >= 2) {
              const combinedOdds = topBets.reduce((acc, bet) => acc * bet.odds, 1);
              suggestions.push({
                name: `${league} Accumulator`,
                bets: topBets,
                totalOdds: combinedOdds,
                avgConfidence: topBets.reduce((sum, b) => sum + b.confidence, 0) / topBets.length,
                description: `${topBets.length} picks from ${league}`,
                risk: 'Medium'
              });
            }
          }
        });

        // Suggestion 3: Value accumulator (higher odds)
        const valueOpps = opportunities.filter(o => o.odds >= 1.5 && o.odds <= 2.5 && o.confidence >= 70);
        if (valueOpps.length >= 2) {
          const valuePicks = [...valueOpps].sort((a, b) => b.confidence - a.confidence).slice(0, 3);
          const combinedOdds = valuePicks.reduce((acc, bet) => acc * bet.odds, 1);
          suggestions.push({
            name: 'Value Accumulator',
            bets: valuePicks,
            totalOdds: combinedOdds,
            avgConfidence: valuePicks.reduce((sum, b) => sum + b.confidence, 0) / valuePicks.length,
            description: `${valuePicks.length} balanced value picks`,
            risk: 'Medium'
          });
        }

        return suggestions.slice(0, 3); // Return max 3 suggestions
      };

      // ============================================================================
      // MULTI-BET FUNCTIONS
      // ============================================================================

      const toggleBetSelection = (opp) => {
        setSelectedBets(prev => {
          const isSelected = prev.some(b => b.id === opp.id);
          if (isSelected) {
            return prev.filter(b => b.id !== opp.id);
          } else {
            return [...prev, opp];
          }
        });
        
        if (!showBetSlip) {
          setShowBetSlip(true);
        }
      };

      const clearBetSlip = () => {
        setSelectedBets([]);
        setAccumulatorStake('');
      };

      const calculateCombinedOdds = () => {
        if (selectedBets.length === 0) return 0;
        return selectedBets.reduce((acc, bet) => acc * bet.odds, 1);
      };

      const getBetTypeName = () => {
        if (selectedBets.length === 1) return 'Single';
        if (selectedBets.length === 2) return 'Double';
        if (selectedBets.length === 3) return 'Treble';
        return `${selectedBets.length}-Fold Accumulator`;
      };

      const handlePlaceMultiBet = () => {
        if (selectedBets.length === 0) return;
        
        const stake = parseFloat(accumulatorStake) || parseFloat(userStakeInput);
        
        if (currentBankroll < stake) {
          alert('Insufficient bankroll for this bet!');
          return;
        }

        const combinedOdds = calculateCombinedOdds();
        const betTypeName = getBetTypeName();
        
        const newBet = {
          id: Date.now(),
          event: selectedBets.map(b => b.event).join(' + '),
          league: 'Multi-Bet',
          selection: selectedBets.map(b => b.selection).join(', '),
          type: betTypeName,
          betType: selectedBets.length === 1 ? 'single' : selectedBets.length === 2 ? 'double' : selectedBets.length === 3 ? 'treble' : 'accumulator',
          bookie: 'Multiple',
          odds: combinedOdds,
          stake: stake,
          potentialReturn: (stake * combinedOdds).toFixed(2),
          profit: ((stake * combinedOdds) - stake).toFixed(2),
          confidence: (selectedBets.reduce((sum, b) => sum + b.confidence, 0) / selectedBets.length).toFixed(1),
          placedAt: new Date().toISOString(),
          status: 'pending',
          multiBetLegs: selectedBets.map(b => ({
            event: b.event,
            selection: b.selection,
            odds: b.odds,
            league: b.league
          }))
        };
        
        setPlacedBets([...placedBets, newBet]);
        setCurrentBankroll(currentBankroll - stake);
        
        // Clear bet slip
        clearBetSlip();
        setShowBetSlip(false);
      };

      // ============================================================================
      // MAIN DATA FETCHER
      // ============================================================================

      const fetchLiveOpportunities = async () => {
        setIsLoadingOpportunities(true);
        setOppsError(null);
        
        const allRecommendations = [];
        const now = new Date();
        const windowStart = new Date(now.getTime() - (12 * 60 * 60 * 1000));
        const windowEnd = new Date(now.getTime() + (2 * 24 * 60 * 60 * 1000));

        const allLeagues = [...LEAGUES.uk, ...LEAGUES.europe];

        console.log('üìä Fetching standings...');
        const standingsMap = {};
        let standingsFetched = 0;
        const priorityLeagues = ['soccer_epl', 'soccer_efl_champ', 'soccer_spain_la_liga', 'soccer_germany_bundesliga'];

        for (const league of allLeagues) {
          if (standingsFetched >= 4) break;
          if (priorityLeagues.includes(league.key)) {
            const standings = await fetchStandings(league.fdId);
            if (standings) {
              standingsMap[league.key] = standings;
              standingsFetched++;
            }
          }
        }

        console.log(`‚úì Loaded standings for ${Object.keys(standingsMap).length} leagues`);

        console.log('üí∞ Fetching odds...');
        for (const league of allLeagues) {
          try {
            let events = await fetchDirectOdds(league.key, API_KEYS.primary, true);
            
            if (events === null) {
              events = await fetchDirectOdds(league.key, API_KEYS.backup, true);
            }

            if (events && events.length > 0) {
              events.forEach(event => {
                const eventTime = new Date(event.commence_time);
                
                if (eventTime >= windowStart && eventTime <= windowEnd) {
                  const analysis = analyzeMatch(event, league.name, standingsMap[league.key]);
                  if (analysis) {
                    allRecommendations.push(analysis);
                  }
                }
              });
            }
          } catch (err) {
            console.error(`Error fetching ${league.name}:`, err);
          }
        }

        allRecommendations.sort((a, b) => b.confidence - a.confidence);
        
        setOpportunities(allRecommendations);
        setLastDataFetch(new Date());
        setIsLoadingOpportunities(false);

        console.log(`‚úÖ Total: ${allRecommendations.length} matches analyzed`);

        if (allRecommendations.length === 0) {
          setOppsError('No matches found in the next 2 days.');
        }
      };

      const fetchLaLigaMatches = async () => {
        setIsLoadingLaLiga(true);
        
        try {
          let events = await fetchDirectOdds('soccer_spain_la_liga', API_KEYS.primary, true);
          
          if (events === null) {
            events = await fetchDirectOdds('soccer_spain_la_liga', API_KEYS.backup, true);
          }

          const standings = await fetchStandings(2014);
          const rmBarcaMatches = [];

          if (events && events.length > 0) {
            events.forEach(event => {
              const homeLower = event.home_team.toLowerCase();
              const awayLower = event.away_team.toLowerCase();

              const isRM = homeLower.includes('real madrid') || awayLower.includes('real madrid');
              const isBarca = homeLower.includes('barcelona') || awayLower.includes('barcelona');

              if (isRM || isBarca) {
                const analysis = analyzeMatch(event, 'La Liga', standings);
                
                if (analysis) {
                  rmBarcaMatches.push({
                    ...analysis,
                    isElClasico: isRM && isBarca
                  });
                }
              }
            });
          }

          setLaLigaMatches(rmBarcaMatches);
        } catch (error) {
          console.error('Error fetching La Liga:', error);
        } finally {
          setIsLoadingLaLiga(false);
        }
      };

      useEffect(() => {
        if (activeTab === 'laliga' && laLigaMatches.length === 0) {
          fetchLaLigaMatches();
        }
      }, [activeTab]);

      const handleSetBankroll = () => {
        const val = parseFloat(initialCapital);
        if (!isNaN(val) && val > 0) setCurrentBankroll(val);
      };

      const handlePlaceBet = (opp, customStake, betType = 'single') => {
        const stake = parseFloat(customStake) || parseFloat(userStakeInput);
        
        if (currentBankroll < stake) {
          alert('Insufficient bankroll for this bet!');
          return;
        }
        
        const newBet = {
          id: Date.now(),
          oppId: opp.id,
          event: opp.event,
          league: opp.league,
          selection: opp.selection,
          type: opp.type || 'Market Analysis',
          betType: betType,
          bookie: opp.bookie,
          odds: opp.odds,
          stake: stake,
          potentialReturn: (stake * opp.odds).toFixed(2),
          profit: ((stake * opp.odds) - stake).toFixed(2),
          confidence: opp.confidence,
          placedAt: new Date().toISOString(),
          status: 'pending'
        };
        
        const updatedPlacedBets = [...placedBets, newBet];
        const updatedBankroll = currentBankroll - stake;
        
        setPlacedBets(updatedPlacedBets);
        setCurrentBankroll(updatedBankroll);
      };

      const handleDeleteBet = (betId) => {
        const bet = placedBets.find(b => b.id === betId);
        if (!bet) return;

        if (window.confirm(`Delete bet on ${bet.event}? Your stake (¬£${bet.stake}) will be returned to your bankroll.`)) {
          setPlacedBets(placedBets.filter(b => b.id !== betId));
          setCurrentBankroll(prev => prev + bet.stake);
        }
      };

      const handleUpdateOdds = (betId, newOdds) => {
        const updatedBets = placedBets.map(bet => {
          if (bet.id === betId) {
            const updatedPotentialReturn = (bet.stake * newOdds).toFixed(2);
            const updatedProfit = (updatedPotentialReturn - bet.stake).toFixed(2);
            return {
              ...bet,
              odds: newOdds,
              potentialReturn: updatedPotentialReturn,
              profit: updatedProfit
            };
          }
          return bet;
        });
        
        setPlacedBets(updatedBets);
      };

      const handleUpdateProfit = (betId, newProfit) => {
        const updatedBets = placedBets.map(bet => {
          if (bet.id === betId) {
            const updatedPotentialReturn = (bet.stake + parseFloat(newProfit)).toFixed(2);
            const updatedOdds = (updatedPotentialReturn / bet.stake).toFixed(2);
            return {
              ...bet,
              profit: newProfit,
              potentialReturn: updatedPotentialReturn,
              odds: parseFloat(updatedOdds)
            };
          }
          return bet;
        });
        
        setPlacedBets(updatedBets);
      };

      const handleUpdateBetType = (betId, newBetType) => {
        const updatedBets = placedBets.map(bet => {
          if (bet.id === betId) {
            return { ...bet, betType: newBetType };
          }
          return bet;
        });
        
        setPlacedBets(updatedBets);
      };

      const handleSettleBet = (betId, won) => {
        const bet = placedBets.find(b => b.id === betId);
        if (!bet) return;

        const settledBet = {
          ...bet,
          status: won ? 'won' : 'lost',
          settledAt: new Date().toISOString(),
          actualReturn: won ? parseFloat(bet.potentialReturn) : 0
        };

        setSettledBets([...settledBets, settledBet]);
        setPlacedBets(placedBets.filter(b => b.id !== betId));
        
        if (won) {
          setCurrentBankroll(prev => prev + parseFloat(bet.potentialReturn));
        }
      };

      const calculateStats = () => {
        const totalBets = settledBets.length;
        const wonBets = settledBets.filter(b => b.status === 'won').length;
        const totalStaked = settledBets.reduce((sum, b) => sum + b.stake, 0);
        const totalReturns = settledBets.reduce((sum, b) => sum + b.actualReturn, 0);
        const calculatedProfit = totalReturns - totalStaked;
        const netProfit = calculatedProfit + manualPLAdjustment;
        const winRate = totalBets > 0 ? ((wonBets / totalBets) * 100).toFixed(1) : 0;

        return { totalBets, wonBets, totalStaked, totalReturns, netProfit, winRate };
      };

      // Memoize accumulator suggestions
      const accumulatorSuggestions = useMemo(() => generateAccumulatorSuggestions(opportunities), [opportunities]);

      const OpportunityCard = ({ opp }) => {
        const [customStake, setCustomStake] = useState('');
        const [isPlacing, setIsPlacing] = useState(false);
        const [isExpanded, setIsExpanded] = useState(false);
        const [showFactors, setShowFactors] = useState(false);
        const [selectedBetType, setSelectedBetType] = useState('single');
        const stakeToUse = customStake || userStakeInput;
        const potReturn = (stakeToUse * opp.odds).toFixed(2);
        const profit = (potReturn - stakeToUse).toFixed(2);
        const alreadyPlaced = placedBets.some(b => b.oppId === opp.id);
        const isHighConfidence = opp.confidence >= 90;
        const isSelected = selectedBets.some(b => b.id === opp.id);

        return (
          <div className={`bg-slate-900 border-2 rounded-2xl shadow-2xl transition-all ${
            isSelected ? 'border-purple-500 shadow-purple-500/30 bet-selected' :
            isHighConfidence ? 'border-emerald-500/60 shadow-emerald-500/20 hover:shadow-emerald-500/30' : 
            'border-slate-700 hover:border-blue-500/50 hover:shadow-blue-500/20'
          }`}>
            <div className="p-6">
              <div className="flex justify-between items-start mb-4">
                <div className="flex-1">
                  <div className="flex items-center gap-2 mb-3 flex-wrap">
                    <span className="px-3 py-1.5 rounded-full text-[10px] font-black uppercase bg-blue-500/20 text-blue-300 border border-blue-500/30">
                      {opp.type}
                    </span>
                    {isHighConfidence && (
                      <span className="px-3 py-1.5 rounded-full text-[10px] font-black uppercase bg-emerald-500/20 text-emerald-300 border border-emerald-500/40">
                        ‚≠ê HIGH CONFIDENCE
                      </span>
                    )}
                    {opp.bookmakerCount > 1 && (
                      <span className="px-3 py-1.5 rounded-full text-[10px] font-black uppercase bg-purple-500/20 text-purple-300 border border-purple-500/30">
                        {opp.bookmakerCount} Bookies
                      </span>
                    )}
                  </div>
                  <h3 className="text-xl font-bold text-white mb-2">{opp.event}</h3>
                  <p className="text-xs text-blue-400 font-bold mb-2">{opp.league}</p>
                  <p className="text-sm text-slate-300 font-bold">{opp.selection} @ {opp.odds.toFixed(2)}</p>
                </div>
                <div className="text-right ml-4">
                  <span className="text-[10px] text-slate-500 font-bold block uppercase tracking-widest mb-1">Confidence</span>
                  <span className={`text-3xl font-black ${isHighConfidence ? 'text-emerald-400' : 'text-white'}`}>
                    {opp.confidence}%
                  </span>
                  <button
                    onClick={() => toggleBetSelection(opp)}
                    className={`mt-3 px-4 py-2 rounded-xl text-xs font-black transition-all border-2 flex items-center gap-2 ${
                      isSelected 
                        ? 'bg-purple-600 text-white border-purple-500' 
                        : 'bg-slate-800 text-slate-300 border-slate-700 hover:bg-purple-600/20 hover:border-purple-500/50'
                    }`}
                  >
                    {isSelected ? <Check size={14} /> : <Plus size={14} />}
                    {isSelected ? 'Selected' : 'Add to Slip'}
                  </button>
                </div>
              </div>

              <button
                onClick={() => setIsExpanded(!isExpanded)}
                className="w-full text-left text-slate-500 text-xs font-bold flex items-center justify-between"
              >
                <span>Click to {isExpanded ? 'collapse' : 'expand'} details</span>
                <span>{isExpanded ? '‚ñº' : '‚ñ∂'}</span>
              </button>

              {isExpanded && (
                <div className="pt-6 border-t border-slate-800 mt-4 animate-in">
                  {opp.insights && opp.insights.length > 0 && (
                    <div className="mb-4 p-4 bg-blue-500/10 rounded-xl border-2 border-blue-500/20">
                      <p className="text-[10px] text-blue-400 font-black uppercase mb-2 flex items-center gap-2">
                        <Target size={12} />
                        KEY INSIGHTS
                      </p>
                      {opp.insights.map((insight, idx) => (
                        <p key={idx} className="text-xs text-slate-300 mb-1 last:mb-0">‚Ä¢ {insight}</p>
                      ))}
                    </div>
                  )}

                  {opp.confidenceFactors && opp.confidenceFactors.length > 0 && (
                    <div className="mb-4">
                      <button
                        onClick={() => setShowFactors(!showFactors)}
                        className="w-full p-3 bg-purple-500/10 border-2 border-purple-500/30 rounded-xl flex items-center justify-between hover:bg-purple-500/20 transition-all"
                      >
                        <div className="flex items-center gap-2">
                          <Target className="text-purple-400" size={16} />
                          <span className="text-xs font-black text-purple-400 uppercase">
                            Detailed Confidence Breakdown ({opp.confidenceFactors.length} Factors)
                          </span>
                        </div>
                        <span className="text-purple-400 text-xs font-bold">
                          {showFactors ? '‚ñº' : '‚ñ∂'}
                        </span>
                      </button>

                      {showFactors && (
                        <div className="mt-3 space-y-2 animate-in">
                          {opp.confidenceFactors.map((factor, idx) => (
                            <div key={idx} className="bg-slate-950 rounded-lg p-3 border-2 border-slate-700">
                              <div className="flex justify-between items-center mb-2">
                                <span className="text-xs font-bold text-slate-300">{factor.name}</span>
                                <span className="text-xs text-emerald-400 font-black">{factor.value} / {factor.max}</span>
                              </div>
                              {factor.description && (
                                <p className="text-[10px] text-slate-500 mb-2">{factor.description}</p>
                              )}
                              <div className="w-full bg-slate-800 rounded-full h-2.5">
                                <div 
                                  className="bg-gradient-to-r from-blue-500 to-emerald-500 h-2.5 rounded-full transition-all"
                                  style={{ width: `${(parseFloat(factor.value) / factor.max) * 100}%` }}
                                />
                              </div>
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  )}

                  <div className="grid grid-cols-1 gap-3 mb-4">
                    <div className="bg-slate-950 p-4 rounded-xl border-2 border-slate-700">
                      <div className="flex justify-between items-center mb-1">
                        <p className="text-[10px] text-slate-500 font-bold uppercase tracking-wider">Bookmaker</p>
                        <a href={opp.url} target="_blank" rel="noopener noreferrer" className="text-[10px] text-blue-400 hover:underline flex items-center gap-1">
                          Visit Site <ArrowUpRight size={10}/>
                        </a>
                      </div>
                      <p className="text-sm font-bold text-white">{opp.bookie} @ <span className="text-blue-400">{opp.odds.toFixed(2)}</span></p>
                    </div>
                  </div>

                  <div className="mb-4 space-y-3">
                    <div className="p-4 bg-blue-500/10 rounded-xl border-2 border-blue-500/20">
                      <p className="text-[10px] text-blue-400 font-black uppercase mb-2">Strategy</p>
                      <p className="text-xs text-slate-300 italic leading-relaxed font-medium">"{opp.strategy}"</p>
                    </div>
                    <p className="text-xs text-slate-400 leading-relaxed font-medium">
                      <span className="text-slate-300 font-bold">Analysis:</span> {opp.reasoning}
                    </p>
                  </div>

                  {!alreadyPlaced && (
                    <>
                      <div className="mb-4 p-4 bg-slate-950 rounded-xl border-2 border-slate-700">
                        <p className="text-[10px] text-slate-500 font-black uppercase mb-2">Bet Type</p>
                        <div className="flex gap-2">
                          {['single', 'accumulator', 'treble'].map(type => (
                            <button
                              key={type}
                              onClick={() => setSelectedBetType(type)}
                              className={`flex-1 px-4 py-2.5 rounded-xl text-xs font-bold transition-all border-2 ${
                                selectedBetType === type 
                                  ? 'bg-blue-600 text-white border-blue-500' 
                                  : 'bg-slate-800 text-slate-400 hover:bg-slate-700 border-slate-700'
                              }`}
                            >
                              {type === 'single' && '1x'}
                              {type === 'accumulator' && <Layers size={14} className="mx-auto" />}
                              {type === 'treble' && '3x'}
                            </button>
                          ))}
                        </div>
                      </div>

                      <div className="mb-4 p-4 bg-slate-950 rounded-xl border-2 border-slate-700">
                        <p className="text-[10px] text-slate-500 font-black uppercase mb-2">Custom Stake (Optional)</p>
                        <div className="flex items-center">
                          <span className="text-lg font-black text-slate-500 mr-2">¬£</span>
                          <input 
                            type="number"
                            placeholder={userStakeInput}
                            className="bg-transparent text-lg font-bold text-white w-full focus:outline-none"
                            value={customStake}
                            onChange={(e) => setCustomStake(e.target.value)}
                          />
                        </div>
                      </div>
                    </>
                  )}

                  <div className="mt-auto pt-4 border-t-2 border-slate-800">
                    {alreadyPlaced ? (
                      <div className="flex items-center justify-center gap-2 p-4 bg-emerald-500/20 rounded-xl border-2 border-emerald-500/40">
                        <CheckSquare size={20} className="text-emerald-400" />
                        <span className="text-sm font-bold text-emerald-400">Bet Placed - Track in Pending Bets</span>
                      </div>
                    ) : (
                      <>
                        <div className="flex justify-between items-center mb-4">
                          <div>
                            <p className="text-[10px] text-slate-500 font-black tracking-widest uppercase mb-1">Est. Return</p>
                            <p className="text-2xl font-black text-emerald-400">¬£{potReturn}</p>
                          </div>
                          <div className="text-right">
                            <p className="text-[10px] text-slate-500 font-black tracking-widest uppercase mb-1">Net Profit</p>
                            <p className="text-xl font-bold text-white">¬£{profit}</p>
                          </div>
                        </div>
                        <button
                          onClick={() => {
                            setIsPlacing(true);
                            setTimeout(() => {
                              handlePlaceBet(opp, customStake, selectedBetType);
                              setIsPlacing(false);
                            }, 500);
                          }}
                          disabled={isPlacing || currentBankroll < stakeToUse}
                          className="w-full bg-blue-600 hover:bg-blue-500 disabled:bg-slate-700 disabled:text-slate-500 text-white py-4 rounded-xl font-black text-sm transition-all active:scale-95 shadow-lg"
                        >
                          {isPlacing ? 'PLACING...' : currentBankroll < stakeToUse ? 'INSUFFICIENT BANKROLL' : 'PLACE SINGLE BET'}
                        </button>
                      </>
                    )}
                  </div>
                </div>
              )}
            </div>
          </div>
        );
      };

      const stats = calculateStats();
      const topNonLiveBets = opportunities.filter(o => !o.isLive).slice(0, 3);

      return (
        <div className="min-h-screen bg-slate-950 text-slate-200">
          
          <nav className="fixed top-0 left-0 right-0 h-20 bg-slate-900/80 backdrop-blur-xl border-b border-slate-800 z-50 px-6 lg:px-12 flex items-center justify-between">
            <div className="flex items-center gap-4">
              <div className="bg-blue-600 p-2 rounded-xl shadow-lg shadow-blue-600/20">
                <Shield className="text-white" size={24} />
              </div>
              <div>
                <h1 className="text-xl font-black text-white tracking-tighter uppercase italic">ABIS Live</h1>
                <p className="text-[9px] text-blue-400 font-black tracking-[0.2em] uppercase">Enhanced v4.0 ‚Ä¢ Multi-Bet System</p>
              </div>
            </div>

            <div className="hidden lg:flex items-center gap-2">
              {[
                { id: 'dashboard', label: 'Dashboard', icon: LayoutDashboard },
                { id: 'laliga', label: 'La Liga', icon: TrendingUp },
                { id: 'history', label: 'Bet History', icon: History }
              ].map(tab => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id)}
                  className={`px-6 py-2.5 rounded-full text-sm font-bold transition-all flex items-center gap-2 ${activeTab === tab.id ? 'bg-blue-600 text-white' : 'text-slate-400 hover:text-white hover:bg-slate-800'}`}
                >
                  <tab.icon size={16} /> {tab.label}
                </button>
              ))}
            </div>

            <button className="lg:hidden text-white" onClick={() => setIsMobileMenuOpen(!isMobileMenuOpen)}>
              {isMobileMenuOpen ? <X /> : <Menu />}
            </button>

            <div className="hidden lg:flex items-center gap-4">
              {selectedBets.length > 0 && (
                <button
                  onClick={() => setShowBetSlip(!showBetSlip)}
                  className="relative px-4 py-2 rounded-full bg-purple-600 text-white font-bold text-sm hover:bg-purple-500 transition-all"
                >
                  Bet Slip ({selectedBets.length})
                  {selectedBets.length > 0 && (
                    <span className="absolute -top-1 -right-1 w-5 h-5 bg-red-500 rounded-full text-xs flex items-center justify-center">
                      {selectedBets.length}
                    </span>
                  )}
                </button>
              )}
              <div className="flex items-center gap-2 px-4 py-2 rounded-full bg-slate-800 border border-slate-700">
                <div className="text-xs text-slate-400">
                  API: {apiUsage.oddsAPI + apiUsage.footballData} calls
                </div>
              </div>
            </div>
          </nav>

          {/* BET SLIP SIDEBAR */}
          {showBetSlip && selectedBets.length > 0 && (
            <div className="fixed top-20 right-0 w-96 h-[calc(100vh-5rem)] bg-slate-900 border-l-2 border-purple-500 z-40 overflow-y-auto shadow-2xl">
              <div className="p-6">
                <div className="flex justify-between items-center mb-6">
                  <h3 className="text-xl font-black text-white">Bet Slip</h3>
                  <button
                    onClick={() => setShowBetSlip(false)}
                    className="text-slate-400 hover:text-white"
                  >
                    <X />
                  </button>
                </div>

                <div className="mb-6 p-4 bg-purple-500/10 border-2 border-purple-500/30 rounded-xl">
                  <p className="text-xs text-purple-400 font-black uppercase mb-2">{getBetTypeName()}</p>
                  <p className="text-2xl font-black text-white">{selectedBets.length} Selection{selectedBets.length > 1 ? 's' : ''}</p>
                  <p className="text-xs text-slate-400 mt-1">Combined Odds: {calculateCombinedOdds().toFixed(2)}</p>
                </div>

                <div className="space-y-3 mb-6">
                  {selectedBets.map((bet, idx) => (
                    <div key={bet.id} className="bg-slate-950 border-2 border-slate-700 rounded-xl p-4">
                      <div className="flex justify-between items-start mb-2">
                        <div className="flex-1">
                          <p className="text-xs text-blue-400 font-bold mb-1">{bet.league}</p>
                          <p className="text-sm font-bold text-white mb-1">{bet.event}</p>
                          <p className="text-xs text-slate-400">{bet.selection}</p>
                        </div>
                        <button
                          onClick={() => toggleBetSelection(bet)}
                          className="text-red-400 hover:text-red-300 ml-2"
                        >
                          <X size={16} />
                        </button>
                      </div>
                      <div className="flex justify-between items-center pt-2 border-t border-slate-800">
                        <span className="text-xs text-slate-500">Odds</span>
                        <span className="text-sm font-bold text-emerald-400">{bet.odds.toFixed(2)}</span>
                      </div>
                    </div>
                  ))}
                </div>

                <div className="mb-6 p-4 bg-slate-950 rounded-xl border-2 border-slate-700">
                  <p className="text-[10px] text-slate-500 font-black uppercase mb-2">Total Stake</p>
                  <div className="flex items-center">
                    <span className="text-lg font-black text-slate-500 mr-2">¬£</span>
                    <input 
                      type="number"
                      placeholder={userStakeInput}
                      className="bg-transparent text-lg font-bold text-white w-full focus:outline-none"
                      value={accumulatorStake}
                      onChange={(e) => setAccumulatorStake(e.target.value)}
                    />
                  </div>
                </div>

                <div className="p-4 bg-slate-950 rounded-xl border-2 border-emerald-500/30 mb-4">
                  <div className="flex justify-between mb-2">
                    <span className="text-xs text-slate-400">Total Stake</span>
                    <span className="text-sm font-bold text-white">¬£{(parseFloat(accumulatorStake) || userStakeInput).toFixed(2)}</span>
                  </div>
                  <div className="flex justify-between mb-2">
                    <span className="text-xs text-slate-400">Combined Odds</span>
                    <span className="text-sm font-bold text-white">{calculateCombinedOdds().toFixed(2)}</span>
                  </div>
                  <div className="flex justify-between pt-2 border-t border-slate-800">
                    <span className="text-xs font-bold text-emerald-400">Potential Return</span>
                    <span className="text-lg font-black text-emerald-400">
                      ¬£{((parseFloat(accumulatorStake) || userStakeInput) * calculateCombinedOdds()).toFixed(2)}
                    </span>
                  </div>
                </div>

                <div className="space-y-2">
                  <button
                    onClick={handlePlaceMultiBet}
                    disabled={currentBankroll < (parseFloat(accumulatorStake) || userStakeInput)}
                    className="w-full bg-purple-600 hover:bg-purple-500 disabled:bg-slate-700 disabled:text-slate-500 text-white py-4 rounded-xl font-black text-sm transition-all active:scale-95 shadow-lg"
                  >
                    PLACE {getBetTypeName().toUpperCase()}
                  </button>
                  <button
                    onClick={clearBetSlip}
                    className="w-full bg-slate-800 hover:bg-slate-700 text-white py-3 rounded-xl font-bold text-sm transition-all"
                  >
                    Clear All
                  </button>
                </div>
              </div>
            </div>
          )}

          {isMobileMenuOpen && (
            <div className="fixed inset-0 top-20 bg-slate-950 z-40 p-6 flex flex-col gap-4 lg:hidden">
              {['dashboard', 'laliga', 'history'].map(id => (
                <button
                  key={id}
                  onClick={() => { setActiveTab(id); setIsMobileMenuOpen(false); }}
                  className={`w-full p-4 rounded-2xl text-left font-bold capitalize ${activeTab === id ? 'bg-blue-600' : 'bg-slate-900'}`}
                >
                  {id}
                </button>
              ))}
            </div>
          )}

          <main className="pt-28 pb-12 px-6 lg:px-12 max-w-[1600px] mx-auto">
            
            {activeTab === 'dashboard' && (
              <div className="animate-in">
                <header className="flex flex-col lg:flex-row justify-between items-start lg:items-center gap-6 mb-12">
                  <div>
                    <h2 className="text-3xl font-black text-white tracking-tight">Active Signals</h2>
                    <p className="text-slate-500 font-medium">
                      Enhanced Multi-Factor Analysis ‚Ä¢ Detailed Insights
                      {lastDataFetch && (
                        <span className="ml-2 text-xs">
                          ‚Ä¢ Last updated: {lastDataFetch.toLocaleTimeString()}
                        </span>
                      )}
                    </p>
                  </div>

                  <button
                    onClick={fetchLiveOpportunities}
                    disabled={isLoadingOpportunities}
                    className="bg-amber-600 hover:bg-amber-500 disabled:bg-slate-700 text-white px-6 py-3 rounded-2xl text-xs font-black transition-all active:scale-95 flex items-center gap-2"
                  >
                    {isLoadingOpportunities ? (
                      <>
                        <div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin" />
                        ANALYZING...
                      </>
                    ) : (
                      <>
                        <Zap size={16} className="fill-current" />
                        REFRESH DATA
                      </>
                    )}
                  </button>
                </header>

                {/* Stats Cards */}
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-12">
                  <div className="bg-slate-900 p-8 rounded-[2rem] border border-slate-800 shadow-xl">
                    <p className="text-[10px] text-slate-500 font-black uppercase mb-2 tracking-widest">Current Bankroll</p>
                    <div className="flex items-center">
                      <span className="text-2xl font-black text-slate-500 mr-1">¬£</span>
                      <input
                        type="number"
                        step="0.01"
                        className="bg-transparent text-3xl font-black text-white w-full focus:outline-none"
                        value={currentBankroll}
                        onChange={(e) => {
                          const val = parseFloat(e.target.value) || 0;
                          setCurrentBankroll(val);
                        }}
                      />
                    </div>
                  </div>
                  <div className="bg-slate-900 p-8 rounded-[2rem] border border-slate-800 shadow-xl">
                    <div className="flex justify-between items-center mb-2">
                      <p className="text-[10px] text-slate-500 font-black uppercase tracking-widest">Total P/L</p>
                      <Edit size={14} className="text-slate-600" />
                    </div>
                    <div className="flex items-center">
                      <span className={`text-2xl font-black mr-1 ${stats.netProfit >= 0 ? 'text-emerald-400' : 'text-red-400'}`}>¬£</span>
                      <input
                        type="number"
                        step="0.01"
                        className={`bg-transparent text-3xl font-black w-full focus:outline-none ${stats.netProfit >= 0 ? 'text-emerald-400' : 'text-red-400'}`}
                        value={stats.netProfit.toFixed(2)}
                        onChange={(e) => {
                          const newTotalPL = parseFloat(e.target.value) || 0;
                          const totalStaked = settledBets.reduce((sum, b) => sum + b.stake, 0);
                          const totalReturns = settledBets.reduce((sum, b) => sum + b.actualReturn, 0);
                          const calculatedProfit = totalReturns - totalStaked;
                          const newAdjustment = newTotalPL - calculatedProfit;
                          setManualPLAdjustment(newAdjustment);
                        }}
                      />
                    </div>
                    {manualPLAdjustment !== 0 && (
                      <p className="text-xs text-slate-500 mt-2">
                        Manual adjustment: {manualPLAdjustment >= 0 ? '+' : ''}¬£{manualPLAdjustment.toFixed(2)}
                      </p>
                    )}
                  </div>
                  <div className="bg-slate-900 p-8 rounded-[2rem] border border-slate-800 shadow-xl">
                    <p className="text-[10px] text-slate-500 font-black uppercase mb-2 tracking-widest">Win Rate</p>
                    <div className="flex items-center gap-2 mt-2">
                      <TrendingUp className="text-emerald-500" size={16} />
                      <span className="text-2xl font-bold text-white">{stats.winRate}%</span>
                    </div>
                    <p className="text-xs text-slate-500 mt-1">{stats.wonBets}/{stats.totalBets} wins</p>
                  </div>
                  <div className="bg-slate-900 p-8 rounded-[2rem] border-2 border-blue-500/30 shadow-2xl bg-gradient-to-br from-slate-900 to-blue-900/10">
                    <div className="flex justify-between items-center mb-2">
                      <p className="text-[10px] text-blue-400 font-black uppercase tracking-widest">Default Stake</p>
                      <Calculator size={14} className="text-blue-400" />
                    </div>
                    <div className="flex items-center">
                      <span className="text-2xl font-black text-slate-500 mr-1">¬£</span>
                      <input 
                        type="number"
                        className="bg-transparent text-3xl font-black text-white w-full focus:outline-none"
                        value={userStakeInput}
                        onChange={(e) => setUserStakeInput(parseFloat(e.target.value) || 10)}
                      />
                    </div>
                  </div>
                </div>

                {currentBankroll === 0 && (
                  <div className="mb-12 p-8 bg-blue-500/5 border-2 border-blue-500/20 rounded-[2rem]">
                    <h3 className="text-lg font-black text-blue-400 mb-4">Set Your Initial Bankroll</h3>
                    <div className="flex gap-3">
                      <div className="flex-1 bg-slate-900 p-2 rounded-xl border border-slate-800">
                        <div className="flex items-center gap-3 px-4">
                          <Wallet className="text-blue-400" size={20} />
                          <input 
                            type="number"
                            placeholder="Enter Initial Bankroll (e.g., 1000)"
                            className="bg-transparent border-none text-white font-black text-lg focus:outline-none w-full placeholder:text-slate-700"
                            value={initialCapital}
                            onChange={(e) => setInitialCapital(e.target.value)}
                          />
                        </div>
                      </div>
                      <button 
                        onClick={handleSetBankroll}
                        className="bg-emerald-600 hover:bg-emerald-500 text-white px-8 py-3 rounded-xl font-black text-sm transition-all"
                      >
                        SET BANKROLL
                      </button>
                    </div>
                  </div>
                )}

                {/* ACCUMULATOR SUGGESTIONS */}
                {accumulatorSuggestions.length > 0 && (
                  <div className="mb-12">
                    <h3 className="text-xs font-black text-slate-500 uppercase tracking-[0.3em] flex items-center gap-3 mb-6">
                      <Layers size={16} className="text-purple-400" /> SUGGESTED ACCUMULATORS
                    </h3>
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                      {accumulatorSuggestions.map((suggestion, idx) => (
                        <div key={idx} className="bg-gradient-to-br from-slate-900 to-purple-900/20 border-2 border-purple-500/50 rounded-[2rem] p-6 shadow-2xl shadow-purple-500/10">
                          <div className="flex justify-between items-start mb-4">
                            <div>
                              <h4 className="text-lg font-black text-white mb-1">{suggestion.name}</h4>
                              <p className="text-xs text-slate-400">{suggestion.description}</p>
                            </div>
                            <span className={`px-2 py-1 rounded-lg text-[9px] font-black uppercase ${
                              suggestion.risk === 'Low' ? 'bg-emerald-500/20 text-emerald-400' :
                              'bg-amber-500/20 text-amber-400'
                            }`}>
                              {suggestion.risk} Risk
                            </span>
                          </div>
                          <div className="space-y-2 mb-4">
                            {suggestion.bets.map((bet, bidx) => (
                              <div key={bidx} className="text-xs text-slate-300 flex justify-between">
                                <span>{bet.event}</span>
                                <span className="text-blue-400">{bet.odds.toFixed(2)}</span>
                              </div>
                            ))}
                          </div>
                          <div className="border-t border-slate-700 pt-4 mb-4">
                            <div className="flex justify-between mb-2">
                              <span className="text-xs text-slate-500">Combined Odds</span>
                              <span className="text-lg font-black text-emerald-400">{suggestion.totalOdds.toFixed(2)}</span>
                            </div>
                            <div className="flex justify-between">
                              <span className="text-xs text-slate-500">Avg Confidence</span>
                              <span className="text-sm font-bold text-white">{suggestion.avgConfidence.toFixed(1)}%</span>
                            </div>
                          </div>
                          <button
                            onClick={() => {
                              setSelectedBets(suggestion.bets);
                              setShowBetSlip(true);
                            }}
                            className="w-full bg-purple-600 hover:bg-purple-500 text-white px-6 py-3 rounded-xl text-xs font-black transition-all active:scale-95 shadow-lg"
                          >
                            ADD TO BET SLIP
                          </button>
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                {topNonLiveBets.length > 0 && (
                  <div className="mb-12">
                    <h3 className="text-xs font-black text-slate-500 uppercase tracking-[0.3em] flex items-center gap-3 mb-6">
                      <Zap size={16} className="text-emerald-400 fill-emerald-400" /> BEST 3 UPCOMING BETS
                    </h3>
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                      {topNonLiveBets.map(opp => (
                        <div key={opp.id} className="bg-gradient-to-br from-slate-900 to-emerald-900/20 border-2 border-emerald-500/50 rounded-[2rem] p-8 shadow-2xl shadow-emerald-500/10 relative overflow-hidden group hover:border-emerald-500 transition-all">
                          <div className="absolute top-0 right-0 p-6">
                            <Zap size={32} className="text-emerald-500/10 group-hover:text-emerald-500/30 transition-all" />
                          </div>
                          <p className="text-[10px] text-emerald-400 font-black uppercase mb-2 tracking-[0.2em]">{opp.league}</p>
                          <h4 className="text-xl font-black text-white mb-1 truncate">{opp.event}</h4>
                          <p className="text-sm text-slate-400 mb-6">{opp.selection} @ <span className="text-emerald-400 font-bold">{opp.odds.toFixed(2)}</span></p>
                          <div className="flex justify-between items-end">
                            <div>
                              <p className="text-[9px] text-slate-500 uppercase font-black mb-1 tracking-widest">Confidence</p>
                              <p className="text-3xl font-black text-white">{opp.confidence}%</p>
                            </div>
                            <div className="flex gap-2">
                              <button
                                onClick={() => toggleBetSelection(opp)}
                                className={`p-3 rounded-xl transition-all ${
                                  selectedBets.some(b => b.id === opp.id)
                                    ? 'bg-purple-600 text-white'
                                    : 'bg-slate-800 text-slate-400 hover:bg-purple-600/20'
                                }`}
                              >
                                {selectedBets.some(b => b.id === opp.id) ? <Check size={16} /> : <Plus size={16} />}
                              </button>
                              <button
                                onClick={() => handlePlaceBet(opp, null, 'single')}
                                disabled={currentBankroll < userStakeInput}
                                className="bg-emerald-600 hover:bg-emerald-500 disabled:bg-slate-700 text-white px-6 py-3 rounded-2xl text-xs font-black transition-all active:scale-95 shadow-lg shadow-emerald-600/20"
                              >
                                PLACE BET
                              </button>
                            </div>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                {placedBets.length > 0 && (
                  <div className="mb-12">
                    <h3 className="text-xs font-black text-slate-500 uppercase tracking-[0.3em] flex items-center gap-3 mb-6">
                      <CheckSquare size={16} className="text-amber-400" /> Pending Bets ({placedBets.length})
                    </h3>
                    <div className="grid gap-4">
                      {placedBets.map(bet => (
                        <div key={bet.id} className="bg-slate-900 border-2 border-slate-700 rounded-2xl p-6 shadow-lg">
                          <div className="flex flex-col gap-4">
                            <div className="flex justify-between items-start">
                              <div className="flex-1">
                                <div className="flex items-center gap-2 mb-2">
                                  <h4 className="text-lg font-bold text-white">{bet.event}</h4>
                                  <span className={`px-2 py-1 rounded-lg text-[9px] font-black uppercase ${
                                    bet.betType === 'single' ? 'bg-blue-500/20 text-blue-400' :
                                    bet.betType === 'double' ? 'bg-purple-500/20 text-purple-400' :
                                    bet.betType === 'treble' ? 'bg-amber-500/20 text-amber-400' :
                                    'bg-red-500/20 text-red-400'
                                  }`}>
                                    {bet.betType}
                                  </span>
                                </div>
                                <p className="text-xs text-blue-400 font-bold mb-2">{bet.league} ‚Ä¢ {bet.selection}</p>
                                
                                {/* Show multi-bet legs if applicable */}
                                {bet.multiBetLegs && bet.multiBetLegs.length > 0 && (
                                  <div className="mt-3 p-3 bg-slate-950/50 rounded-xl border border-slate-700">
                                    <p className="text-[10px] text-slate-500 font-black uppercase mb-2">Bet Legs</p>
                                    {bet.multiBetLegs.map((leg, idx) => (
                                      <div key={idx} className="text-xs text-slate-400 mb-1 last:mb-0 flex justify-between">
                                        <span>{leg.event} - {leg.selection}</span>
                                        <span className="text-blue-400">{leg.odds.toFixed(2)}</span>
                                      </div>
                                    ))}
                                  </div>
                                )}
                              </div>
                              <button
                                onClick={() => handleDeleteBet(bet.id)}
                                className="text-red-400 hover:text-red-300 transition-colors"
                                title="Delete bet"
                              >
                                <Trash size={18} />
                              </button>
                            </div>

                            <div className="grid grid-cols-2 md:grid-cols-5 gap-4 text-xs">
                              <div>
                                <p className="text-slate-500 uppercase text-[10px] mb-1">Stake</p>
                                <p className="text-white font-bold">¬£{bet.stake}</p>
                              </div>
                              <div>
                                <p className="text-slate-500 uppercase text-[10px] mb-1">Odds</p>
                                <div className="flex items-center gap-1">
                                  <input
                                    type="number"
                                    step="0.01"
                                    value={bet.odds}
                                    onChange={(e) => handleUpdateOdds(bet.id, parseFloat(e.target.value))}
                                    className="bg-slate-950 border border-slate-700 rounded px-2 py-1 w-16 text-white font-bold text-xs focus:outline-none focus:border-blue-500"
                                  />
                                  <Edit size={12} className="text-slate-600" />
                                </div>
                              </div>
                              <div>
                                <p className="text-slate-500 uppercase text-[10px] mb-1">Profit</p>
                                <div className="flex items-center gap-1">
                                  <span className="text-slate-600">¬£</span>
                                  <input
                                    type="number"
                                    step="0.01"
                                    value={bet.profit}
                                    onChange={(e) => handleUpdateProfit(bet.id, parseFloat(e.target.value))}
                                    className="bg-slate-950 border border-slate-700 rounded px-2 py-1 w-16 text-emerald-400 font-bold text-xs focus:outline-none focus:border-emerald-500"
                                  />
                                  <Edit size={12} className="text-slate-600" />
                                </div>
                              </div>
                              <div>
                                <p className="text-slate-500 uppercase text-[10px] mb-1">Return</p>
                                <p className="text-white font-bold">¬£{bet.potentialReturn}</p>
                              </div>
                              <div>
                                <p className="text-slate-500 uppercase text-[10px] mb-1">Bet Type</p>
                                <select
                                  value={bet.betType}
                                  onChange={(e) => handleUpdateBetType(bet.id, e.target.value)}
                                  className="bg-slate-950 border border-slate-700 rounded px-2 py-1 text-white font-bold text-xs focus:outline-none focus:border-blue-500"
                                >
                                  <option value="single">Single</option>
                                  <option value="double">Double</option>
                                  <option value="treble">Treble</option>
                                  <option value="accumulator">Accumulator</option>
                                </select>
                              </div>
                            </div>

                            <div className="flex gap-2 pt-2 border-t border-slate-800">
                              <button
                                onClick={() => handleSettleBet(bet.id, true)}
                                className="flex-1 bg-emerald-600 hover:bg-emerald-500 text-white px-6 py-3 rounded-xl text-xs font-black transition-all"
                              >
                                WON
                              </button>
                              <button
                                onClick={() => handleSettleBet(bet.id, false)}
                                className="flex-1 bg-red-600 hover:bg-red-500 text-white px-6 py-3 rounded-xl text-xs font-black transition-all"
                              >
                                LOST
                              </button>
                            </div>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                <div className="mb-12">
                  <h3 className="text-xs font-black text-slate-500 uppercase tracking-[0.3em] flex items-center gap-3 mb-8">
                    <Zap className="text-amber-400 fill-amber-400" size={16} /> 
                    All Recommendations ({opportunities.length})
                  </h3>
                  
                  {isLoadingOpportunities ? (
                    <div className="text-center py-20">
                      <div className="w-16 h-16 border-4 border-blue-600 border-t-transparent rounded-full animate-spin mx-auto mb-4" />
                      <p className="text-slate-400 font-bold">Running enhanced multi-factor analysis...</p>
                      <p className="text-slate-600 text-sm mt-2">Analyzing odds, standings, form, consensus & timing</p>
                    </div>
                  ) : opportunities.length === 0 ? (
                    <div className="text-center py-20 bg-slate-900/40 border-2 border-dashed border-slate-800 rounded-[3rem]">
                      <div className="w-16 h-16 bg-slate-800 rounded-full flex items-center justify-center mb-6 mx-auto">
                        <Zap className="text-slate-600" size={32} />
                      </div>
                      <h3 className="text-2xl font-black text-white mb-2">No Opportunities</h3>
                      <p className="text-slate-500 max-w-sm mx-auto font-medium mb-6">
                        Click "REFRESH DATA" to fetch the latest opportunities
                      </p>
                      <button
                        onClick={fetchLiveOpportunities}
                        className="bg-blue-600 hover:bg-blue-500 text-white px-8 py-4 rounded-2xl font-black text-sm transition-all"
                      >
                        REFRESH DATA NOW
                      </button>
                    </div>
                  ) : (
                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                      {opportunities.map(opp => (
                        <OpportunityCard key={opp.id} opp={opp} />
                      ))}
                    </div>
                  )}
                </div>
              </div>
            )}

            {activeTab === 'laliga' && (
              <div className="animate-in">
                <header className="flex justify-between items-center mb-12">
                  <div>
                    <h2 className="text-3xl font-black text-white tracking-tight mb-2">Real Madrid & Barcelona</h2>
                    <p className="text-slate-500 font-medium">Enhanced multi-factor analysis with detailed insights</p>
                  </div>
                  <button
                    onClick={fetchLaLigaMatches}
                    disabled={isLoadingLaLiga}
                    className="bg-blue-600 hover:bg-blue-500 disabled:bg-slate-700 text-white px-6 py-3 rounded-2xl text-xs font-black transition-all flex items-center gap-2"
                  >
                    {isLoadingLaLiga ? 'LOADING...' : 'REFRESH'}
                  </button>
                </header>

                {isLoadingLaLiga ? (
                  <div className="text-center py-20">
                    <div className="w-16 h-16 border-4 border-blue-600 border-t-transparent rounded-full animate-spin mx-auto mb-4" />
                    <p className="text-slate-400 font-bold">Analyzing matches...</p>
                  </div>
                ) : laLigaMatches.length === 0 ? (
                  <div className="text-center py-20 bg-slate-900/40 border-2 border-dashed border-slate-800 rounded-[3rem]">
                    <div className="w-16 h-16 bg-slate-800 rounded-full flex items-center justify-center mb-6 mx-auto">
                      <TrendingUp className="text-slate-600" size={32} />
                    </div>
                    <h3 className="text-2xl font-black text-white mb-2">No Upcoming Matches</h3>
                    <p className="text-slate-500 max-w-sm mx-auto font-medium mb-6">
                      No Real Madrid or Barcelona matches in the next 2 days
                    </p>
                  </div>
                ) : (
                  <div className="grid gap-8">
                    {laLigaMatches.map(match => {
                      const homeProb = (1 / match.homeOdds) * 100;
                      const awayProb = (1 / match.awayOdds) * 100;
                      const drawProb = (1 / match.drawOdds) * 100;

                      let likelyScore = "";
                      let outcome = "";
                      let outcomeProb = 0;

                      if (homeProb > awayProb && homeProb > drawProb) {
                        outcome = "Home Win";
                        outcomeProb = homeProb;
                        likelyScore = homeProb > 75 ? "3-0" : homeProb > 65 ? "2-0" : homeProb > 55 ? "2-1" : "1-0";
                      } else if (awayProb > homeProb && awayProb > drawProb) {
                        outcome = "Away Win";
                        outcomeProb = awayProb;
                        likelyScore = awayProb > 75 ? "0-3" : awayProb > 65 ? "0-2" : awayProb > 55 ? "1-2" : "0-1";
                      } else {
                        outcome = "Draw";
                        outcomeProb = drawProb;
                        likelyScore = homeProb > 40 && awayProb > 40 ? "2-2" : "1-1";
                      }

                      return (
                        <div key={match.id} className={`bg-slate-900 border-2 rounded-2xl shadow-2xl p-8 ${
                          match.isElClasico ? 'border-red-500/60 shadow-red-500/20' : 'border-blue-500/50 hover:border-blue-500 shadow-blue-500/10'
                        }`}>
                          {match.isElClasico && (
                            <div className="bg-gradient-to-r from-red-600 to-blue-600 text-white text-sm font-black px-6 py-3 rounded-xl -mx-8 -mt-8 mb-6 text-center uppercase">
                              ‚öΩ EL CL√ÅSICO ‚öΩ
                            </div>
                          )}
                          
                          <div className="flex items-center justify-between mb-6">
                            <h3 className="text-2xl font-black text-white">{match.event}</h3>
                            <span className="text-sm text-slate-400">
                              {new Date(match.commence_time).toLocaleDateString()} at {new Date(match.commence_time).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                            </span>
                          </div>
                          
                          {match.insights && match.insights.length > 0 && (
                            <div className="mb-6 p-4 bg-blue-500/10 rounded-xl border-2 border-blue-500/20">
                              <p className="text-[10px] text-blue-400 font-black uppercase mb-2 flex items-center gap-2">
                                <Target size={12} />
                                MATCH INSIGHTS
                              </p>
                              {match.insights.map((insight, idx) => (
                                <p key={idx} className="text-xs text-slate-300 mb-1 last:mb-0">‚Ä¢ {insight}</p>
                              ))}
                            </div>
                          )}
                          
                          <div className="bg-gradient-to-br from-blue-500/10 to-purple-500/10 border-2 border-blue-500/30 rounded-2xl p-6 mb-6">
                            <div className="flex items-center gap-3 mb-4">
                              <div className="bg-blue-500 p-2 rounded-lg">
                                <TrendingUp size={20} className="text-white" />
                              </div>
                              <h4 className="text-lg font-black text-white">PREDICTION</h4>
                            </div>
                            
                            <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                              <div className="bg-slate-950/50 rounded-xl p-4 text-center border-2 border-slate-700">
                                <p className="text-xs text-slate-400 uppercase mb-2 font-bold">Likely Score</p>
                                <p className="text-4xl font-black text-emerald-400">{likelyScore}</p>
                              </div>
                              <div className="bg-slate-950/50 rounded-xl p-4 text-center border-2 border-slate-700">
                                <p className="text-xs text-slate-400 uppercase mb-2 font-bold">Outcome</p>
                                <p className="text-xl font-black text-blue-400">{outcome}</p>
                                <p className="text-xs text-slate-500 mt-1">{outcomeProb.toFixed(1)}% prob</p>
                              </div>
                              <div className="bg-slate-950/50 rounded-xl p-4 text-center border-2 border-slate-700">
                                <p className="text-xs text-slate-400 uppercase mb-2 font-bold">Confidence</p>
                                <p className="text-4xl font-black text-amber-400">{match.confidence}%</p>
                              </div>
                            </div>

                            <div className="grid grid-cols-3 gap-4">
                              <div className="bg-slate-950/70 rounded-lg p-3 border border-slate-700">
                                <p className="text-[10px] text-slate-500 uppercase mb-1 font-bold">Home Win</p>
                                <p className="text-lg font-black text-white">{match.homeOdds.toFixed(2)}</p>
                                <p className="text-xs text-slate-400">{homeProb.toFixed(1)}%</p>
                              </div>
                              <div className="bg-slate-950/70 rounded-lg p-3 border border-slate-700">
                                <p className="text-[10px] text-slate-500 uppercase mb-1 font-bold">Draw</p>
                                <p className="text-lg font-black text-white">{match.drawOdds.toFixed(2)}</p>
                                <p className="text-xs text-slate-400">{drawProb.toFixed(1)}%</p>
                              </div>
                              <div className="bg-slate-950/70 rounded-lg p-3 border border-slate-700">
                                <p className="text-[10px] text-slate-500 uppercase mb-1 font-bold">Away Win</p>
                                <p className="text-lg font-black text-white">{match.awayOdds.toFixed(2)}</p>
                                <p className="text-xs text-slate-400">{awayProb.toFixed(1)}%</p>
                              </div>
                            </div>
                          </div>

                          {match.reasoning && (
                            <div className="bg-slate-950/50 rounded-2xl p-6 mb-6 border-2 border-slate-700">
                              <p className="text-xs text-slate-500 uppercase font-black mb-2">Detailed Analysis</p>
                              <p className="text-sm text-slate-300 leading-relaxed">{match.reasoning}</p>
                            </div>
                          )}

                          <div className="flex justify-end gap-3">
                            <button
                              onClick={() => toggleBetSelection(match)}
                              className={`p-3 rounded-xl transition-all ${
                                selectedBets.some(b => b.id === match.id)
                                  ? 'bg-purple-600 text-white'
                                  : 'bg-slate-800 text-slate-400 hover:bg-purple-600/20'
                              }`}
                            >
                              {selectedBets.some(b => b.id === match.id) ? <Check size={16} /> : <Plus size={16} />}
                            </button>
                            <button
                              onClick={() => handlePlaceBet(match, null, 'single')}
                              disabled={currentBankroll < userStakeInput}
                              className="bg-emerald-600 hover:bg-emerald-500 disabled:bg-slate-700 text-white px-8 py-4 rounded-2xl font-black text-sm transition-all active:scale-95 flex items-center gap-2 shadow-lg"
                            >
                              <Zap size={16} className="fill-current" />
                              PLACE BET ON {outcome.toUpperCase()}
                            </button>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                )}
              </div>
            )}

            {activeTab === 'history' && (
              <div className="animate-in">
                {settledBets.length === 0 ? (
                  <div className="text-center py-40">
                    <div className="p-6 bg-slate-900 rounded-full w-fit mx-auto mb-6">
                      <History className="text-slate-700" size={40} />
                    </div>
                    <h3 className="text-2xl font-black text-white mb-2 tracking-tight uppercase italic">No History Found</h3>
                    <p className="text-slate-500 max-w-sm mx-auto font-medium">
                      Bet history will populate once you place and settle bets from the dashboard.
                    </p>
                  </div>
                ) : (
                  <div>
                    <header className="mb-8">
                      <h2 className="text-3xl font-black text-white mb-2">Bet History</h2>
                      <p className="text-slate-500">Complete record of all settled bets</p>
                    </header>

                    <div className="grid gap-4">
                      {settledBets.map(bet => (
                        <div key={bet.id} className={`bg-slate-900 border-2 rounded-2xl p-6 shadow-lg ${bet.status === 'won' ? 'border-emerald-500/50' : 'border-red-500/50'}`}>
                          <div className="flex flex-col md:flex-row justify-between gap-4">
                            <div className="flex-1">
                              <div className="flex items-center gap-3 mb-2">
                                <span className={`px-3 py-1 rounded-full text-[10px] font-black uppercase ${bet.status === 'won' ? 'bg-emerald-500/20 text-emerald-400' : 'bg-red-500/20 text-red-400'}`}>
                                  {bet.status.toUpperCase()}
                                </span>
                                <span className={`px-2 py-1 rounded-lg text-[9px] font-black uppercase ${
                                  bet.betType === 'single' ? 'bg-blue-500/20 text-blue-400' :
                                  bet.betType === 'double' ? 'bg-purple-500/20 text-purple-400' :
                                  bet.betType === 'treble' ? 'bg-amber-500/20 text-amber-400' :
                                  'bg-red-500/20 text-red-400'
                                }`}>
                                  {bet.betType}
                                </span>
                                <span className="text-xs text-slate-500">
                                  {new Date(bet.settledAt).toLocaleDateString()}
                                </span>
                              </div>
                              <h4 className="text-lg font-bold text-white mb-1">{bet.event}</h4>
                              <p className="text-xs text-blue-400 font-bold mb-3">{bet.league} ‚Ä¢ {bet.selection}</p>
                              
                              {/* Show multi-bet legs if applicable */}
                              {bet.multiBetLegs && bet.multiBetLegs.length > 0 && (
                                <div className="mt-3 p-3 bg-slate-950/50 rounded-xl border border-slate-700">
                                  <p className="text-[10px] text-slate-500 font-black uppercase mb-2">Bet Legs</p>
                                  {bet.multiBetLegs.map((leg, idx) => (
                                    <div key={idx} className="text-xs text-slate-400 mb-1 last:mb-0 flex justify-between">
                                      <span>{leg.event} - {leg.selection}</span>
                                      <span className="text-blue-400">{leg.odds.toFixed(2)}</span>
                                    </div>
                                  ))}
                                </div>
                              )}
                              
                              <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-xs mt-3">
                                <div>
                                  <p className="text-slate-500 uppercase text-[10px] mb-1">Stake</p>
                                  <p className="text-white font-bold">¬£{bet.stake.toFixed(2)}</p>
                                </div>
                                <div>
                                  <p className="text-slate-500 uppercase text-[10px] mb-1">Odds</p>
                                  <p className="text-white font-bold">{bet.odds.toFixed(2)}</p>
                                </div>
                                <div>
                                  <p className="text-slate-500 uppercase text-[10px] mb-1">Return</p>
                                  <p className="text-white font-bold">¬£{bet.actualReturn.toFixed(2)}</p>
                                </div>
                                <div>
                                  <p className="text-slate-500 uppercase text-[10px] mb-1">Profit</p>
                                  <p className={`font-bold ${bet.status === 'won' ? 'text-emerald-400' : 'text-red-400'}`}>
                                    ¬£{(bet.actualReturn - bet.stake).toFixed(2)}
                                  </p>
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            )}
          </main>
        </div>
      );
    };

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
